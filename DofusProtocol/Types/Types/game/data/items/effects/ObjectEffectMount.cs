

//Generated by Kenshin
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Stump.Core.IO;

namespace Stump.DofusProtocol.Types
{
    public class ObjectEffectMount : ObjectEffect
    {
        public const short Id = 7839;
        public override short TypeId
        {
            get { return Id; }
        }
        
        public bool sex;
        public bool isRideable;
        public bool isFeconded;
        public bool isFecondationReady;
        public ulong id;
        public ulong expirationDate;
        public uint model;
        public string name;
        public string owner;
        public sbyte level;
        public int reproductionCount;
        public uint reproductionCountMax;
        public IEnumerable<Types.ObjectEffectInteger> effects;
        public IEnumerable<uint> capacities;
        
        public ObjectEffectMount()
        {
        }
        
        public ObjectEffectMount(ushort actionId, bool sex, bool isRideable, bool isFeconded, bool isFecondationReady, ulong id, ulong expirationDate, uint model, string name, string owner, sbyte level, int reproductionCount, uint reproductionCountMax, IEnumerable<Types.ObjectEffectInteger> effects, IEnumerable<uint> capacities)
         : base(actionId)
        {
            this.sex = sex;
            this.isRideable = isRideable;
            this.isFeconded = isFeconded;
            this.isFecondationReady = isFecondationReady;
            this.id = id;
            this.expirationDate = expirationDate;
            this.model = model;
            this.name = name;
            this.owner = owner;
            this.level = level;
            this.reproductionCount = reproductionCount;
            this.reproductionCountMax = reproductionCountMax;
            this.effects = effects;
            this.capacities = capacities;
        }
        
        public override void Serialize(IDataWriter writer)
        {
            base.Serialize(writer);
            byte flag1 = 0;
            flag1 = BooleanByteWrapper.SetFlag(flag1, 0, sex);
            flag1 = BooleanByteWrapper.SetFlag(flag1, 1, isRideable);
            flag1 = BooleanByteWrapper.SetFlag(flag1, 2, isFeconded);
            flag1 = BooleanByteWrapper.SetFlag(flag1, 3, isFecondationReady);
            writer.WriteByte(flag1);
            writer.WriteVarULong(id);
            writer.WriteVarULong(expirationDate);
            writer.WriteVarUInt(model);
            writer.WriteUTF(name);
            writer.WriteUTF(owner);
            writer.WriteSByte(level);
            writer.WriteVarInt(reproductionCount);
            writer.WriteVarUInt(reproductionCountMax);
            writer.WriteShort((short)effects.Count());
            foreach (var objectToSend in effects)
            {
                 objectToSend.Serialize(writer);
            }
            writer.WriteShort((short)capacities.Count());
            foreach (var objectToSend in capacities)
            {
                 writer.WriteVarUInt(objectToSend);
            }
        }
        
        public override void Deserialize(IDataReader reader)
        {
            base.Deserialize(reader);
            byte flag1 = reader.ReadByte();
            sex = BooleanByteWrapper.GetFlag(flag1, 0);
            isRideable = BooleanByteWrapper.GetFlag(flag1, 1);
            isFeconded = BooleanByteWrapper.GetFlag(flag1, 2);
            isFecondationReady = BooleanByteWrapper.GetFlag(flag1, 3);
            id = reader.ReadVarULong();
            expirationDate = reader.ReadVarULong();
            model = reader.ReadVarUInt();
            name = reader.ReadUTF();
            owner = reader.ReadUTF();
            level = reader.ReadSByte();
            reproductionCount = reader.ReadVarInt();
            reproductionCountMax = reader.ReadVarUInt();
            var effectsCount = reader.ReadUShort();
            var effects_ = new Types.ObjectEffectInteger[effectsCount];
            for (var effectsIndex = 0; effectsIndex < effectsCount; effectsIndex++)
            {
                 var objectToAdd = new Types.ObjectEffectInteger();
                 objectToAdd.Deserialize(reader);
                 effects_[effectsIndex] = objectToAdd;
            }
            effects = effects_;
            var capacitiesCount = reader.ReadUShort();
            var capacities_ = new uint[capacitiesCount];
            for (var capacitiesIndex = 0; capacitiesIndex < capacitiesCount; capacitiesIndex++)
            {
                 capacities_[capacitiesIndex] = reader.ReadVarUInt();
            }
            capacities = capacities_;
        }
    }
}